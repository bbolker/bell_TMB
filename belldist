#include <Rcpp.h>
#include <cmath>

// Lambert W function for the principal branch (W_0)
// Using Halley's method for numerical approximation
double lambertW0(double z) {
    if (z == 0.0) {
        return 0.0;
    }
    if (z == -1.0 / std::exp(1.0)) {
        return -1.0;
    }
    if (z < -1.0 / std::exp(1.0)) {
        return NAN; // No real solution exists
    }

    double w = z;
    double tolerance = 1e-10;
    for (int i = 0; i < 100; ++i) {
        double ew = std::exp(w);
        double wew = w * ew;
        double wewz = wew - z;
        double w1 = w + 1.0;
        double delta_w = wewz / (ew * w1 - (w + 2.0) * wewz / (2.0 * w1));
        w -= delta_w;
        if (std::abs(delta_w) < tolerance) {
            return w;
        }
    }
    return w; // Return the last approximation if convergence not achieved
}

// Expose the function to R
// [[Rcpp::export]]
double lambertW(double z) {
    return lambertW0(z);
}
// [[Rcpp::export]]
double bell(int n) {
  std::vector<double> bell_numbers(n + 1, 0.0);
  bell_numbers[0] = 1;
  for (int i = 1; i <= n; ++i) {
    for (int j = 0; j < i; ++j) {
      bell_numbers[i] += bell_numbers[j] * std::pow(i - 1, j) / std::tgamma(j + 1);
    }
  }
  return bell_numbers[n];
}

// [[Rcpp::export]]
Rcpp::NumericVector dbell(Rcpp::IntegerVector x, double theta, bool log_prob = false) {
  int n = x.size();
  Rcpp::NumericVector result(n);
  for (int i = 0; i < n; ++i) {
    double Bx = bell(x[i]);
    double lf = x[i] * std::log(theta) - theta + std::log(Bx) - std::lgamma(x[i] + 1);
    result[i] = log_prob ? lf : std::exp(lf);
  }
  return result;
}
